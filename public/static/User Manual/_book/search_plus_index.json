{"./":{"url":"./","title":"BSN Spartan Data Center User Manual","keywords":"","body":" BSN Spartan Data Center User Manual version 1.1.1 Nov. 30, 2022 Download PDF Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"overview/overview.html":{"url":"overview/overview.html","title":"Overview","keywords":"","body":"1 Overview document.location='whatisBSNSpartan.html' Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"overview/whatisBSNSpartan.html":{"url":"overview/whatisBSNSpartan.html","title":"What is BSN Spartan","keywords":"","body":"What is BSN Spartan Glossary Glossary Definition Non-Cryptocurrency Public Chain (NC Public Chain) A Non-Cryptocurrency Public Chain is a transformed public chain framework based on an existing public chain. Gas Credit transfers are not permitted between standard wallets. There will be no cryptocurrency incentives for mining or participating in consensus. End-user An end-user refers to a person or company that deploys or calls smart contracts on the BSN Spartan Network. Virtual Data Center A Virtual Data Center is a set of locally installed software systems that contains one or more registered full nodes of different NC Public Chains. Each Virtual Data Center has one NTT wallet and is eligible to receive Node Establishment and Data Center Monthly Incentives. Foundation Member Foundation Members refer to the members of the BSN Foundation. Each member must operate a Governance Data Center, which contains all NC Public Chain consensus nodes, and has the right to vote on governance matters of the BSN Spartan Network. Consensus Node Nodes are used for proposing new blocks and voting for consensus mechanisms on NC Public Chains. Consensus Nodes can only be installed on Governance Data Centers operated by BSN Foundation members. Full Node A Full Node on an NC Public Chain does not participate in consensus. Upon registering a Full Node on the BSN Spartan Network, it synchronizes all data on the specific chain. The data center to which the Full Node belongs will receive relevant incentives under the Node Establishment Incentive Program. Spartan-I Chain (Powered by NC Ethereum) The Spartan-I Chain is an NC Public Chain version of Ethereum and serves as the default chain of the BSN Spartan Network. Spartan-II Chain (Powered by NC Cosmos) The Spartan-II Chain is an NC Public Chain version of Cosmos. Spartan-III Chain (Powered by NC PolygonEdge) The Spartan-III Chain is an NC Public Chain version of Polygon Edge. Gas In NC Public Chains, Gas is the amount of resources consumed during a transaction or smart contract execution. Gas Credit In a similar fashion to cryptocurrencies, Gas Credits are used as a means of paying the Gas fee on NC Public Chains. However, Gas Credits cannot be transferred between standard wallets. Only the Data Center Operator's NTT wallet can be used to purchase Gas Credits with NTT. Wallet Wallet refers to the wallet address or smart contract address of an NC Public Chain on the BSN Spartan Network, which can be generated arbitrarily by users. The wallets are used to hold non-transferable Gas Credits. Gas Credit Master Wallets A Gas Credit Master Wallet refers to the wallet address, or smart contract address used to mint, top up, or destroy the Gas Credits of NC Public Chains. A Gas Credit Master Wallet can only be generated by the Spartan Network operator with permission from the BSN Foundation. Governance System The governance system is an off-chain system installed locally by each Foundation member and is responsible for managing the voting and governance of the Spartan Network. Foundation Website The official website of the BSN Foundation at https://www.bsn.foundation. What is blockchain \" A blockchain is a type of Digital Ledger Technology (DLT) that consists of growing list of records, called blocks, which are securely linked together using cryptography. \" Blockchain technology was used to build digital ledgers when it was first invented, but with the continuous upgrading and iteration of the technology, various innovative applications based on blockchain continue to emerge, and NFTs are one of the most common applications. The emergence of NFTs clearly tells the world that the potential of blockchain technology is far more than a small ledger, but a new generation of data management system that could replace traditional databases. For a healthy and secure blockchain system, the data on the chain cannot be secretly tampered with, nor can it be accidentally deleted. Users can easily verify the data's authenticity and accuracy, which greatly reduces the cost of communication, increases trust and improves the efficiency of data use. In addition, in our opinion, blockchain will also become a pivotal technology to promote the evolution of traditional private IT systems to new public IT systems. What is Non-Cryptocurrency Public Chain A Non-Cryptocurrency Public Chain is a transformed public chain framework based on an existing public chain. Gas Credit transfers are not permitted between standard wallets. There are no cryptocurrency incentives for mining or participating in consensus. What is a Wallet Wallet refers to the wallet address or smart contract address of an NC Public Chain on the BSN Spartan Network, which can be generated arbitrarily by users. The wallets are used to hold non-transferable Gas Credits. Full Node & Consensus Node Full Nodes: A Full Node on a NC Public Chain does not participate in consensus. Upon registering a Full Node on the BSN Spartan Network, it synchronizes all data on the specific chain. The data center to which the Full Node belongs will receive relevant incentives under the Node Establishment Incentive Program. Consensus/Validator Nodes: Nodes are used for proposing new blocks and voting for consensus mechanisms on NC Public Chains. Consensus Nodes can only be installed on Governance Data Centers operated by BSN Foundation members. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"overview/roles.html":{"url":"overview/roles.html","title":"Roles","keywords":"","body":"Roles Data Center Operator A Data Center Operator is the operator of a Virtual Data Center. A Virtual Data Center is a set of locally installed software systems that contains one or more registered full nodes of different NC Public Chains. Each Virtual Data Center has one NTT wallet and is eligible to receive Node Establishment and Data Center Monthly Incentives. Foundation Member Foundation Members refers to the members of the BSN Foundation. Each member must operate a Governance Data Center, which contains all NC Public Chain consensus nodes and has the right to vote on governance matters of the BSN Spartan Network. End-user An end-user refers to a person or company that deploys or calls smart contracts on the BSN Spartan Network. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"overview/whyBSNSpartan.html":{"url":"overview/whyBSNSpartan.html","title":"Why BSN Spartan","keywords":"","body":"Why BSN Spartan The purpose of the BSN Spartan project is to develop, build and promote a global decentralized cloud service network that consists of non-cryptocurrency public chains for enterprise uses and utilities without any speculative elements. Public vs. Private Traditional IT systems are built on independent and non-public databases, each company has its own unique data storage mechanism and structure, and the cost of data exchange between systems is very high. Even if it is public data, a user must go to various websites to download and collect the data. This process is destined to become unacceptable in the future, with ever-increasing demands for digitization. The Spartan network can solve this problem to a certain extent. Due to the openness of blockchain data and the characteristics of the consensus mechanism, all data centers using the Spartan network will be able to easily share data because the data is only logically isolated; as long as permissions are provided to each other, the data can be exchanged. Complex data migration will be a thing of the past. Using the Spartan network, a user just needs to connect to the network and the data will be synchronized and accessed from anywhere with any device. On any full node a user can obtain all public data generated by different end users. This will greatly improve the efficiency of data acquisition and use. Cryptocurrency vs. Non-Cryptocurrency Cost control is a critical task for traditional industries and costs must be predictable. However, the value of cryptocurrencies that traditional public chains need to consume for normal transactions fluctuates. Yesterday, a transaction may cost 1 USD and today it costs 5 USD, and this fluctuation is unpredictable. Due to this volatility, almost no traditional industries have built their businesses using blockchain technology. The three non-cryptocurrency public chains launched by the Spartan Network fundamentally eliminate the volatility of costs to use the chains by prohibiting the transfer of Gas Credits between standard wallets. Furthermore, Gas Credit can only be purchased with NTT, which is anchored to fiat currency. The cost becomes predictable. This makes Spartan Network capable of supporting traditional industries and organizations can use Spartan Network as their underlying infrastructure with confidence they can manage costs effectively. Centralized vs. Decentralized When a user interacts with a centralized system, all the requests initiated to the system and all the information entered is owned and controlled by the system’s backend. This centralized architecture allows operators to easily modify any data, and it is difficult for users to verify the authenticity and accuracy of the data. The Spartan Network benefits from blockchain’s consensus mechanism, which prevents data from being secretly tampered after being uploaded to the chain and allows users to easily verify any data. At the same time, Spartan also strictly implements decentralized governance and all new or changed governance rules are voted by all consensus parties. Blockchain vs. Infrastructure Compared with traditional public chains, the Spartan Network is more scalable and provides technology diversity. A single public chain is often subject to various performance bottlenecks, resulting in a long processing cycle for transactions on the chain. The Spartan Network is a multi-chain ecosystem and the data exchange between each chain is realized through the interchain services. At the same time, different chain frameworks have their own characteristics and often have their own advantages. Looking ahead to the future, different chains may be suitable for different industries and fields. Users can choose according to their own needs. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/gettingStarted.html":{"url":"gettingstarted/gettingStarted.html","title":"Getting Started","keywords":"","body":"Getting Started document.location='getaWalletAddress.html' Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/getaWalletAddress.html":{"url":"gettingstarted/getaWalletAddress.html","title":"Get a Wallet Address","keywords":"","body":"Get a Wallet Address An Existing secp256k1 Wallet Address If you already have a private key generated by the secp256k1 algorithm and its corresponding wallet address, such as an Ethereum wallet address, you can use that wallet address directly. Using MetaMask You can download MetaMask here and create an account for free. The account address in MetaMask can be used as a Wallet Address, and the corresponding private key is the same. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/gainthechainaccessinformation.html":{"url":"gettingstarted/gainthechainaccessinformation.html","title":"Gain the Chain Access Information","keywords":"","body":"Gain the Chain Access Information Enter your email address and we will send you the access information of the Non-Cryptocurrency public chains. Select a chain you want to access, then input the email address and get the verification code. Then, click the \"Confirm\" button to submit your application. Shortly, BSN Spartan Network Data Center Portal will notify you by email and you are able to access the BSN Spartan Network via the nodes provided by the Spartan Network data center. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/gatewayAccessInstruction.html":{"url":"gettingstarted/gatewayAccessInstruction.html","title":"Gateway Access Instruction","keywords":"","body":"Gateway Access Instruction Key Parameters Access key: accessKey Target chain type: chainType Protocol: protocol Gateway Request Format HTTP Request https://[domain:port]/api/[accessKey]/[chainType]/rpc/[chain_path] [!Note|style:flat] [chain_path] is not required, can be null. Example: https://[domain:port]/api/015416c06ef74ac38a92521792f97e7d/spartanone/rpc WebSocket Request wss://[domain:port]/api/[accessKey]/[chainType]/ws/[chain_path] [!Note|style:flat] [chain_path] is not required, can be null. Example: wss://[ domain:port]/api/015416c06ef74ac38a92521792f97e7d/spartanone/ws gRPC Request [domain:port] Request header: x-api-key: [accessKey] x-api-chain-type: [chainType] [!Note|style:flat] The access information can be found in the notification email of Network Access Information. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/topUpGasCredit.html":{"url":"gettingstarted/topUpGasCredit.html","title":"Top Up Gas Credit","keywords":"","body":"Top Up Gas Credit Any Wallet in the Non-Cryptocurrency Public Chains must consume Gas Credit when initiating a transaction. For example, if a user wants to initiate a transaction, the user’s Wallet needs to consume Gas Credit. At this time, users must use fiat currency or USDC to top up the Gas Credit of the Wallet to ensure that the transaction can proceed normally. Operation Steps Visit BSN Spartan Data Center Portal and click \"Top Up Gas Credit\": Select a chain, enter your wallet address and confirm it. Then, enter the amount of Gas Credit you would like to top up. Enter an email address and verify it by entering the verification code. The next step is to choose the payment method. BSN Spartan Network Data Center Portal supports 3 methods: Remittance, Stripe or Coinbase (pay in USDC); Click the \"Confirm\" button, the system will generate an order number and jump to the payment platform you selected. Complete the payment on the pop-up window; Pay by Remittance: We will send you an email with the payment information. Pay by Stripe: As shown in the above figure, confirm the invoice and enter your card information. After the payment is completed, you will receive a notification by email. [!Note|style:flat] When paying with Stripe, you cannot exceed $999,999.99 in a single transaction. Pay by Coinbase: You can make the payment in USDC. After the payment is successful, you will receive a notification by email. [!danger|style:flat] All payments above are made by the third-party payment platform, and the Spartan Network Data Center Portal will never obtain your account information. Check the email of Submitted Order Users will receive an email notification when the order is submitted. You may also complete the payment via the link in the email. Check the email of Successful Payment Users will receive an email notification when the payment succeeds. Check the email of Successful Top-up Users will receive an email notification when the Gas Credit top-up succeeds. Users can check the Gas Credit information through the link in the email. Check the Currency or USDC Refund (If Top-up Failed) Please make sure the Currency or USDC is correctly refunded. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/contractMarketplace.html":{"url":"gettingstarted/contractMarketplace.html","title":"Contract Marketplace","keywords":"","body":"Contract Marketplace BSN Official Contract Services This group of smart contracts is already deployed on the Spartan Network by BSN Foundation or BSN-authorized third parties. They provide some most basic and common functions and methods of blockchain smart contracts. Developers can directly call these smart contracts without rebuilding similar functions again. Most of these smart contracts are open source. BSN official contract services are defaultly listed in all data center end-user portals and integrated into the data center APIs/SDKs for easy access. BSN Certified Smart Contracts This group of smart contracts is fully open source and can be downloaded, modified, and redeployed onto BSN Spartan Network for any commercial or personal use. The BSN team has reviewed and certified these smart contracts and encourages BSN Spartan users and developers to reuse these brilliant smart contracts as they see fit. Some open-source smart contracts from BSN Official Services and BSN Beginner Contracts are also included. BSN Beginner Smart Contracts This group of smart contracts is specifically designed and consolidated together for beginners to learn smart contract development based on the solidity programming language. These smart contracts contain some of the most basic and common examples, methods, and functions, such as tokens, NFT, storage, DID, Multisignature, etc. It is encouraged that beginners should not only review the codes but also modify whatever they see fit and deploy different versions onto BSN Spartan Network to fully test and practice different business scenarios based on smart contract technologies. BSN Smart Contract Open Market In order to help you understand the Spartan network and smart contracts more intuitively and comprehensively, we have collected a large number of open-source smart contract projects and verified their compatibility through actual deployment in the Spartan network. You can directly deploy the smart contract projects that fit your business needs in the Spartan network or modify some of the smart contracts to meet your business needs and then deploy them. Please double-check the copyright/copyleft statements in these open-source projects to make sure you fully understand the related IP rights before use. [!Tip|style:flat] For a detailed introduction to smart contract marketplace, Please click here. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/spartanOfficialSmartContracts.html":{"url":"gettingstarted/spartanOfficialSmartContracts.html","title":"Spartan Official Smart Contracts (Optional)","keywords":"","body":"Spartan Official Smart Contracts (Optional) These Spartan Network Official Smart Contracts are pre-deployed smart contracts managed by Spartan Network operators for performing different tasks. They are open to all end-users to call and execute. These smart contracts are also open-source on Spartan Network GitHub and can be used for developers to study as use cases. We welcome interested developers to deploy more commercial smart contracts for specific business models and scenarios. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/did.html":{"url":"gettingstarted/did.html","title":"Spartan DID ","keywords":"","body":"Spartan DID Overview With blockchain technology as the cornerstone and W3C DID as the specification, Spartan DID Services achieve decentralized on-chain mapping of real entities, thus achieving the ability to provide digital identity and digital credential interaction for individuals/organizations. Roles In the DID ecosystem, there are three roles: User, Issuer, and Verifier. User: Any individual/organization/entity with a digital identity on the chain. Any entity object can create and manage its DID through the developer’s own project. Issuer: The individual or organization that can issue the digital credentials. For example, a university can issue a digital diploma to a student; then the university is an issuer. Verifier: Also known as a business party, is an individual or organization that uses digital credentials. After being authorized by the user, the verifier can verify the identity of the user or their digital credentials. For example, when a company hires someone, it needs to verify his college diploma, then the company is a verifier. Components The DID system consists of three components: SDK, Service and Smart Contract. The SDK can be integrated into the developer’s own project; Service is responsible for logic processing and communication with nodes; the smart contract is deployed on the chain, and the methods in the contract are called by the DID Service. Functions and features Deployed on the Spartan-I Chain (NC Ethereum), the DID Service builds a decentralized digital identity management system, which facilitates autonomous participation and affirmative collaboration among users, issuers, and verifiers. Provide a unified decentralized digital identity management, including identifier creation, update, and verification functions. Provide mechanisms for issuance, authorization, verification, and revocation of user data credentials. Provide the SDK that access to API services, integrate object encapsulation, signature, verification, and other methods for easy docking by developers. [!Tip|style:flat] For a detailed introduction to DID, Please refer to GitHub. And, BSN-Spartan has also completely open sourced IdentityHub, users can install it locally and store their own private data. For more details, Please refer to GitHub. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/USDStablecoinSmartContract.html":{"url":"gettingstarted/USDStablecoinSmartContract.html","title":"SpartanUSD Stablecoin Smart Contract","keywords":"","body":"SpartanUSD Stablecoin Smart Contract The SpartanUSD Stablecoin is an ERC20-based Token, issued by the Spartan Network operators officially through the stablecoin contract on Spartan-III Chain (NC PolygonEdge), which is strictly anchored to USDC in a ratio of 1:1. The basic functions in the stablecoin contract are Mint, Transfer, Withdraw and Burn. The circulation of the stablecoin will be strictly controlled within a range not greater than the amount of USDC pledged by the stablecoin users into the USDC wallet on the Polygon mainnet. Basic Information SpartanUSD Contract Address: 0x1fD89dc1f4Ffbb797d471D6BB0dbb8EfEABdbe9c on the Spartan-III chain USDC Pledge Wallet Address: 0x764b33c01a611597438f0286e946633685ed3d2f on Polygon (Matic Network) Maximum Counting Accuracy: 6 Decimals (0.000001 SUSD) Name: SpartanUSD Symbol: SUSD Transfer Service Fee: 0.1% of the amount of SUSD transferred Withdraw Service Fee: 0.003 SUSD Common Functions Mint SpartanUSD By calling the official USDC contract (contract address: 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174 on Polygon (Matic Network), the user uses the transfer() method to transfer USDC equal to the expected issuance amount of SUSD to the account (account address: 0x764b33c01a611597438f0286e946633685ed3d2f on Polygon (Matic Network)). Spartan obtains transaction information by listening related events, and the SpartanUSD contract will be called to mint the same amount of SUSD to the user account of the Spartan-III chain (Powered by NC PolygonEdge) through the minter account of SpartanUSD. The Spartan-III user account address is the same as the address of the sender account of the USDC transaction on Polygon. [!note|style:flat] Please ensure the security of the private key of the Polygon account of the USDC transfer transaction sender, which will also be used as the private key of the Spartan-III wallet receiving SUSD. Transfer SpartanUSD The user can transfer their SpartanUSD asset to any other Spartan-III wallet by calling the SUSD contract’s transfer() method (contract address: 0x1fD89dc1f4Ffbb797d471D6BB0dbb8EfEABdbe9c on the Spartan-III Chain). The transfer() method will charge a service fee of 0.1% of the caller's transaction amount, and the service fee will not exceed 10 USD. Input Parameters: Receiver Wallet Address (on the Spartan-III chain), Transfer Amount (Please enter a multiple of 10000, 10000 = 0.01SUSD); [!note|style:flat] The Transfer Amount needs to be a value which is a multiple of 10000, because SUSD’s accuracy is 6 decimals, so, the value of 10000 is equivalent to 0.01 SUSD. Output Parameters: A bool parameter shows successful or failed; Method Definition: transfer (address to, uint256 amount) returns (bool); Event Parameters: Sender Wallet Address, Receiver Wallet Address, Transfer Amount, Service Fee; Event Definition: Transfer (msg.sender, to, amount, serviceCharge); Example: func TestTransfer(t *testing.T) { cli, err := ethclient.Dial(NodeUrl) if err != nil { log.Logger.Error(err) } instance, err := stablecoin.NewStablecoin(common.HexToAddress(Address), cli) if err != nil { log.Logger.Error(err) } auth, err := eth.GenAuth(cli, PrivateKey) if err != nil { log.Logger.Error(err) } tx, err := instance.Transfer(auth, common.HexToAddress(to), new(big.Int).SetUint64(amount)) if err != nil { log.Logger.Error(err) } fmt.Println(\"tx Hash:\", tx.Hash().String()) } Withdraw SpartanUSD The user can withdraw their SpartanUSD asset to USDC which will be transferred to a Polygon (Matic Network) wallet by calling the SUSD contract’s withdraw() method (contract address: 0x1fD89dc1f4Ffbb797d471D6BB0dbb8EfEABdbe9c on the Spartan-III Chain). The withdraw() method will charge a constant service fee of 0.003 SUSD. Input Parameters: Receiver Account Address (on Polygon (Matic Network)), Withdraw Amount; [!note|style:flat] The SUSD balance of the sender account address needs to be greater than the total price of the transaction (withdraw amount + withdraw service fee). Output Parameters: None; Method Definition: withdraw (address payee, uint256 amount); Event Parameter: Sender Wallet Address, Withdraw Amount, Service Fee, Receiver Wallet Address (on Polygon (Matic Network)); Event Definition: Withdraw (msg.sender, amount, _withdrawFee, payee); Example: func TestWithdraw(t *testing.T) { cli, err := ethclient.Dial(NodeUrl) if err != nil { log.Logger.Error(err) } instance, err := stablecoin.NewStablecoin(common.HexToAddress(Address), cli) if err != nil { log.Logger.Error(err) } auth, err := eth.GenAuth(cli, PrivateKey) if err != nil { log.Logger.Error(err) } tx, err := instance.Withdraw(auth, common.HexToAddress(payee), new(big.Int).SetUint64(amount)) if err != nil { log.Logger.Error(err) } fmt.Println(\"tx Hash:\", tx.Hash().String()) } Check SpartanUSD Balance Users can check their SpartanUSD balance by calling the SUSD contract’s balanceOf() method. Input Parameters: Target Account Address (on the Spartan-III chain); Output Parameters: Balance; Method Definition: balanceOf (address account) view returns (uint256); Example: func TestBalanceOf(t *testing.T) { cli, err := ethclient.Dial(NodeUrl) if err != nil { log.Logger.Error(err) } instance, err := stablecoin.NewStablecoin(common.HexToAddress(Address), cli) if err != nil { log.Logger.Error(err) } balance, err := instance.BalanceOf(nil, common.HexToAddress(Address)) if err != nil { log.Logger.Error(err) } fmt.Println(\"balance:\", balance.String()) } Check the Circulation of SpartanUSD Users can check the total circulation of SpartanUSD by calling the SUSD contract’s totalSupply() method. After the mint() method, the total circulation will be increased by the amount of mint and after the withdraw() or burn() method, the total circulation will be decreased by the amount of withdraw or burn. Input Parameters: None; Output Parameters: The Total Circulation of SUSD; Method Definition: totalSupply() view returns (uint256); Example: func TestTotalSupply(t *testing.T) { cli, err := ethclient.Dial(NodeUrl) if err != nil { log.Logger.Error(err) } instance, err := stablecoin.NewStablecoin(common.HexToAddress(Address), cli) if err != nil { log.Logger.Error(err) } totalSupply, err := instance.TotalSupply(nil) if err != nil { log.Logger.Error(err) } fmt.Println(\"totalSupply:\", totalSupply.String()) } Check the Maximum Transaction Service Fee Users can check the maximum transaction service fee by calling the SUSD contract’s TestMaximumTransferCharge() method. The return value is counted in units of 0.000001 SUSD (6 decimals), for example, 1000000 means 1 USUD. Input Parameters: None; Output Parameters: The maximum transaction service fee; Method Definition: maximumTransferCharge() view returns (uint256); Example: func TestMaximumTransferCharge(t *testing.T) { cli, err := ethclient.Dial(NodeUrl) if err != nil { log.Logger.Error(err) } instance, err := stablecoin.NewStablecoin(common.HexToAddress(Address), cli) if err != nil { log.Logger.Error(err) } maximumTransferCharge, err := instance.MaximumTransferCharge(nil) if err != nil { log.Logger.Error(err) } fmt.Println(\"maximumTransferCharge:\", maximumTransferCharge.String()) } Check the Transaction Service Fee Ratio Users can check the transaction service fee ratio by calling the SUSD contract’s getTransferRatio() method. The return value is counted in units of 0.0001 (4 decimals), for example, 10 means 0.001 (0.1%). Input Parameters: None; Output Parameters: the transaction service fee ratio (counted in units of 0.0001); Method Definition: getTransferRatio() view returns (uint256); Example: func TestGetTransferRatio(t *testing.T) { cli, err := ethclient.Dial(NodeUrl) if err != nil { log.Logger.Error(err) } instance, err := stablecoin.NewStablecoin(common.HexToAddress(Address), cli) if err != nil { log.Logger.Error(err) } transferRatio, err := instance.GetTransferRatio(nil) if err != nil { log.Logger.Error(err) } fmt.Println(\"transferRatio:\", transferRatio.String()) } Check the Maximum Amount of SUSD for Transfer Users can check the maximum amount of SUSD for transfer and the service fee for running a transfer of your input amount SUSD by calling the SUSD contract’s queryTransferLimit() method. Input Parameters: SUSD Amount of a transfer; Output Parameters: Service Fee, the Maximum Amount of SUSD; Method Definition: queryTransferLimit (uint256 amount) view returns (uint256 serviceCharge, uint256 maxTransferAmount); Example: func TestQueryTransferLimit(t *testing.T) { cli, err := ethclient.Dial(NodeUrl) if err != nil { log.Logger.Error(err) } instance, err := stablecoin.NewStablecoin(common.HexToAddress(Address), cli) if err != nil { log.Logger.Error(err) } outstruct, err := instance.QueryTransferLimit(nil, new(big.Int).SetUint64(amount)) if err != nil { log.Logger.Error(err) } fmt.Println(\"ServiceCharge:\", outstruct.ServiceCharge.String()) fmt.Println(\"MaxTransferAmount:\", outstruct.MaxTransferAmount.String()) } Check the Maximum Amount of SUSD for Withdraw Users can check the maximum amount of SUSD for withdraw and the service fee for running a withdraw method by calling the SUSD contract’s queryWithdrawLimit() method. Input Parameters: None; Output Parameters: Service Fee, the Maximum Amount of SUSD for withdraw; Method Definition: queryWithdrawLimit() view returns (uint256 withdrawFee, uint256 maxWithdrawAmount); Example: func TestQueryWithdrawLimit(t *testing.T) { cli, err := ethclient.Dial(NodeUrl) if err != nil { log.Logger.Error(err) } instance, err := stablecoin.NewStablecoin(common.HexToAddress(Address), cli) if err != nil { log.Logger.Error(err) } outstruct, err := instance.QueryWithdrawLimit(nil) if err != nil { log.Logger.Error(err) } fmt.Println(\"WithdrawFee:\", outstruct.WithdrawFee.String()) fmt.Println(\"MaxWithdrawAmount:\", outstruct.MaxWithdrawAmount.String()) } Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/nft.html":{"url":"gettingstarted/nft.html","title":"Spartan Official NFT Smart Contract","keywords":"","body":"Spartan Official NFT Smart Contract document.location='nft721.html' Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/nft721.html":{"url":"gettingstarted/nft721.html","title":"Spartan-NFT-721","keywords":"","body":"Spartan-NFT-721 Function Introduction The Spartan-NFT-721 proxy contract is used to provide a complete set of APIs corresponding to ERC-721 methods. The interfaces include functions like Spartan-NFT mint, authorization, query authorization, transfer and destruction. The purpose of this set of contracts is to allow end-users to directly create and manage ERC721 NFTs under the governance of BSN Foundation. Smart contract address: Spartan-I Chain (Powered by NC Ethereum): 0xD1A6C2dbCdbafbF0eCD033B38B83DbE0904caA4b Spartan-II Chain (Powered by NC Cosmos): 0x8fC9EC239fe077ce57a5C5D825e47Ffc2979Fbf8 Spartan-III Chain (Powered by NC PolygonEdge): 0x55aa4279ec99E3952803b791b869B8911761f02A Example: https://github.com/BSN-Spartan/NFT.git API Definition Mint Users can mint NFTs by calling this interface. Input parameters: receiver address, NFT name, NFT symbol, uri; Output parameters: none; Function definition: mint (address to, string memory name, string memory symbol, string memory tokenURI); Event parameters: 0x0 address (null address), receiver address, NFT token ID; Event definition: Transfer (address (0), to, tokenID); Example: func TestMint(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tx, err := session.Mint(common.HexToAddress(owner), \"sparton_nft\", \"sparton_nft\", \"sparton_nft\") if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Safe Mint Users can safe mint NFTs by calling this interface. Input parameters: receiver address, NFT name, NFT symbol, uri, attached args; Output parameters: none; Function definition: safeMint (address to, string memory name, string memory symbol, string memory tokenURI, bytes memory data); Event parameters: 0x0 address (null address), receiver address, NFT token ID; Event definition: Transfer (address (0), to, tokenID); Example: func TestSafeMint(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } data := []byte{0x1} tx, err := session.SafeMint(common.HexToAddress(owner), \"sparton_nft\", \"sparton_nft\", \"sparton_nft\", data) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } NFT Authorization An NFT owner can call this API to authorize the NFT, the sender of the transaction must be the NFT owner. Input parameters: authorizer’s wallet address, NFT token ID; Output parameters: none; Function definition: approve (address to, uint256 tokenID); Event parameters: owner’s wallet address, authorizer’s wallet address, NFT token ID; Event definition: Approval (operator, to, tokenID); Example: func TestApprove(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(1) tx, err := session.Approve(common.HexToAddress(account), tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Query NFT Authorization Users can call this interface to query the NFT authorization. Input parameters: NFT token ID; Output parameters: authorizer’s wallet address; Function definition: getApproved (uint256 tokenID) view returns (address); Example: func TestGetApproved(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(1) tx, err := session.GetApproved(tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"Account Address: %s\", tx.String())) } Wallet Authorization An NFT owner can call this interface to authorize the wallet address, the sender of the transaction must be the NFT owner. Input parameters: authorizer’s wallet address, authorization ID; Output parameters: none; Function definition: setApprovalForAll (address operator, bool approved); Event parameters: owner’s wallet address, authorizer’s wallet address, authorization ID; Event definition: ApprovalForAll (owner, operator, approved); Example: func TestSetApprovalForAll(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tx, err := session.SetApprovalForAll(common.HexToAddress(account), true) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Verify Wallet Authorization Users can call this interface to verify the wallet authorization. Input parameters: owner’s wallet address, authorizer’s wallet address; Output parameters: Boolean value; Function definition: isApprovedForAll (address owner, address operator) view returns (bool); Example: func TestIsApprovedForAll(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tx, err := session.IsApprovedForAll(common.HexToAddress(owner), common.HexToAddress(account)) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"Is ApprovedForAll:%t\", tx)) } Safe Transfer An NFT owner or authorized wallet address can call this interface to safe transfer the NFT. Input parameters: owner’s wallet address, receiver address, NFT token ID, attached args; Output parameters: none; Function definition: safeTransferFrom (address from, address to, uint256 tokenID, bytes memory data); Event parameters: owner’s wallet address, receiver address, NFT token ID; Event definition: Transfer (from, to, tokenID); Example: func TestSafeTransferFrom(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } data := []byte{0x1} tokenId := new(big.Int).SetUint64(1) tx, err := session.SafeTransferFrom(common.HexToAddress(owner), common.HexToAddress(account), tokenId, data) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Transfer An NFT owner or authorized wallet address can call this interface to transfer the NFT. Input parameters: owner’s wallet address, receiver address, NFT token ID; Output parameters: none; Function definition: transferFrom (address from, address to, uint256 tokenID); Event parameters: owner’s wallet address, receiver address, NFT token ID; Event definition: Transfer (from, to, tokenID); Example: func TestTransferFrom(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(2) tx, err := session.TransferFrom(common.HexToAddress(owner), common.HexToAddress(account), tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } NFT Destruction An NFT owner or authorized wallet address can call this interface to destroy the NFT. Input parameters: NFT token ID; Output parameters: none; Function definition: burn (uint256 tokenID); Event parameters: owner’s wallet address, 0x0 address (null address), NFT token ID; Event definition: Transfer (owner, address (0), tokenID); Example: func TestBurn(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(1) tx, err := session.Burn(tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Query Quantity Users can call this interface to query the quantity of the NFTs owned by this wallet address. Input parameters: owner’s wallet address; Output parameters: number of NFTs; Function definition: balanceOf (address owner) view returns (uint256); Example: func TestBalanceOf(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tx, err := session.BalanceOf(common.HexToAddress(owner)) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"nft amount: %s\", tx)) } Query NFT Owner Users can call this interface to query the owner of the NFT. Input parameters: NFT token ID; Output parameters: owner’s wallet address; Function definition: ownerOf (uint256 tokenID) view returns (address); Example: func TestOwnerOf(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(2) tx, err := session.OwnerOf(tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"Owner address: %s\", tx.Hash().String())) } Query NFT Name Users can call this interface to query the NFT name. Input parameters: NFT token ID; Output parameters: NFT name; Function definition: tokenName (uint256 tokenID) view returns (string memory); Example: ffunc TestTokenName(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(2) tx, err := session.TokenName(tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"NFT name: %s\", tx)) } Query NFT Symbol Users can call this interface to query the NFT symbol. Input parameters: NFT token ID; Output parameters: NFT symbol; Function definition: tokenSymbol (uint256 tokenID) view returns (string memory); Example: func TestTokenSymbol(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(2) tx, err := session.TokenSymbol(tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"NFT symbol: %s\", tx)) } Query NFT URI Users can call this interface to query the NFT URI. Input parameters: NFT token ID; Output parameters: NFT URI; Function definition: tokenURI (uint256 tokenID) view returns (string memory); Example: func TestTokenURI(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(2) tx, err := session.TokenURI(tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"NFT URI: %s\", tx)) } Query Latest Token ID Users can call this interface to query the latest NFT token ID. Input parameters: none; Output parameters: latest NFT token ID; Function definition: getLatestTokenID() view returns (uint256); Example: func TestGetLatestTokenID(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC721Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tx, err := session.GetLatestTokenID() if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tokenId: %s\", tx)) } Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"gettingstarted/nft1155.html":{"url":"gettingstarted/nft1155.html","title":"Spartan-NFT-1155","keywords":"","body":"Spartan-NFT-1155 Function Introduction Spartan-NFT-1155 proxy contract is used to provide users with a set of APIs, including mint and batch mint Spartan-NFTs under the standard of ERC1155, as well as authorization, query authorization, transfer, batch transfer and destruction. The purpose of this set of smart contracts is to allow end-users to directly mint ERC1155 NFTs under the governance of BSN Foundation. Smart contract address: Spartan-I Chain (Powered by NC Ethereum): 0xD4366bBeF0977f278A91Ae20EfE8A035690Ac90B Spartan-II Chain (Powered by NC Cosmos): 0xD0Bf538c75310917b2C82C0a715E126783Be030F Spartan-III Chain (Powered by NC PolygonEdge): 0x0c0f445f359eBa39935012C0EEeaFE3cA00B6BFb Example: https://github.com/BSN-Spartan/NFT.git API Definition Safe Mint Users can call this interface to safe mint the NFT. Input parameters: receiver address, NFT name, NFT symbol, number of copies of the NFT, uri, attached args; Output parameters: none; Function definition: safeMint (address to, string memory name, string memory symbol, uint256 amount, string memory tokenURI, bytes memory data); Event parameters: operator, 0x0 address (null address), receiver address, NFT token ID, number of copies; Event definition: TransferSingle (operator, address (0), to, tokenID, amount); Example: func TestSafeMint(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } amount := new(big.Int).SetUint64(1) data := []byte{0x1} tx, err := session.SafeMint(common.HexToAddress(owner), \"sparton_nft\", \"sparton_nft\", amount, \"sparton_nft\", data) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Batch Safe Mint NFT Users can call this interface to safer mint the NFT in batch. Input parameters: receiver address, NFT name set, NFT symbol set, number of NFT copies set, uri set, attached args; Output parameters: none; Function name: safeMintBatch; Function definition: safeMintBatch (address to, string[] memory names, string[] memory symbols, uint256[] memory amounts, string[] memory tokenURIs, bytes memory data); Event parameters: operator, 0x0 address (null address), receiver address, NFT token ID set, number of copies set; Event definition: TransferBatch (operator, address (0), to, tokenIDs, amounts); Example: func TestSafeMintBatch(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenName := []string{\"sparton_nft_1\", \"sparton_nft_2\"} tokenSymbol := []string{\"sparton_nft_1\", \"sparton_nft_2\"} tokenURIs := []string{\"http://sparton.json\", \"http://sparton.json\"} var amount []*big.Int amount = append(amount, new(big.Int).SetUint64(1), new(big.Int).SetUint64(1)) data := []byte{0x1, 0x2} tx, err := session.SafeMintBatch(common.HexToAddress(owner), tokenName, tokenSymbol, amount, tokenURIs, data) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Wallet Authorization NFT owner can call this interface to wallet authorization, the sender of the transaction must be the NFT owner. Input parameters: authorizer’s wallet address, authorization ID; Output parameters: none; Function definition: setApprovalForAll (address operator, bool approved); Event parameters: NFT owner, authorizer’s wallet address, authorization ID; Event definition: ApprovalForAll (owner, operator, approved); Example: func TestSetApprovalForAll(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tx, err := session.SetApprovalForAll(common.HexToAddress(account), true) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Verify Wallet Authorization Users can call this interface to verify the wallet authorization. Input parameters: owner’s wallet address, authorizer’s wallet address; Output parameters: Boolean value; Function definition: isApprovedForAll (address owner, address operator) view returns (bool); Example: func TestIsApprovedForAll(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tx, err := session.IsApprovedForAll(common.HexToAddress(owner), common.HexToAddress(account)) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"Is ApprovedForAll:%t\", tx)) } Safe Transfer An NFT owner or authorized wallet address can call this interface to transfer the NFT. Input parameters: owner’s wallet address, receiver’s wallet address, NFT token ID, number of copies, attached args; Output parameters: none; Function definition: safeTransferFrom (address from, address to, uint256 tokenID, uint256 amount, bytes memory data); Event parameters: operator, owner’s wallet address, receiver’s wallet address, NFT token ID, number of copies; Event definition: TransferSingle (operator, from, to, tokenID, amount); Example: func TestSafeTransferFrom(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } data := []byte{0x1} tokenId := new(big.Int).SetUint64(1) amount := new(big.Int).SetUint64(1) tx, err := session.SafeTransferFrom(common.HexToAddress(owner), common.HexToAddress(account), tokenId, amount, data) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Batch Safe Transfer An NFT owner or authorized wallet address can call this interface to transfer NFTs in batch. Input parameters: owner’s wallet address, receiver’s wallet address, NFT token ID set, number of copies set, attached args; Output parameters: none; Function definition: safeBatchTransferFrom (address from, address to, uint256[] memory tokenIDs, uint256[] memory amounts, bytes memory data); Event parameters: operator, owner’s wallet address, receiver’s wallet address, NFT token ID set, number of copies set; Event definition: TransferBatch (operator, from, to, tokenIDs, amounts); Example: func TestSafeBatchTransferFrom(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } var tokenIDs []*big.Int tokenIDs = append(tokenIDs, new(big.Int).SetUint64(1), new(big.Int).SetUint64(2)) var amount []*big.Int amount = append(amount, new(big.Int).SetUint64(1), new(big.Int).SetUint64(1)) data := []byte{0x1, 0x2} tx, err := session.SafeBatchTransferFrom(common.HexToAddress(owner), common.HexToAddress(account), tokenIDs, amount, data) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } NFT Destruction An NFT owner or authorized wallet address can call this interface to destroy the NFT. Input parameters: owner’s wallet address, NFT token ID; Output parameters: none; Function definition: burn (address owner, uint256 tokenID); Event parameters: operator, owner’s wallet address, 0x0 address (null address), NFT token ID, number of copies; Event definition: TransferSingle (operator, owner, address (0), tokenID, amount); Example: func TestBurn(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(1) tx, err := session.Burn(common.HexToAddress(owner), tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Batch Destruction An NFT owner or authorized wallet address can call this interface to destroy NFTs in batch. Input parameters: owner’s wallet address, NFT token ID set; Output parameters: none; Function definition: burnBatch (address owner, uint256[] memory tokenIDs); Event parameters: operator, owner’s wallet address, 0x0 address (null address), NFT token ID set, number of copies set; Event definition: TransferBatch (operator, owner, address (0), tokenIDs, amounts); Example: func TestBurnBatch(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } var tokenIDs []*big.Int tokenIDs = append(tokenIDs, new(big.Int).SetUint64(3), new(big.Int).SetUint64(4)) tx, err := session.BurnBatch(common.HexToAddress(owner), tokenIDs) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tx Hash: %s\", tx.Hash().String())) } Query Number of NFT Copies Users can call this interface to query the number of NFT copies held by this wallet address. Input parameters: owner’s wallet address, NFT token ID; Output parameters: number of copies; Function definition: balanceOf (address owner, uint256 tokenID) view returns (uint256); Example: func TestBalanceOf(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(3) tx, err := session.BalanceOf(common.HexToAddress(owner), tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"Account balance: %s\", tx)) } Batch Query the Number of NFT Copies Users can call this interface to query the number of NFT copies held by this wallet address in batches. Input parameters: owner’s wallet address set, NFT token ID set; Output parameters: number of copies set; Function definition: balanceOfBatch (address[] memory owners, uint256[] memory tokenIDs) view returns (uint256[] memory); Example: func TestBalanceOfBatch(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } var tokenIDs []*big.Int tokenIDs = append(tokenIDs, new(big.Int).SetUint64(3), new(big.Int).SetUint64(4)) var owners []common.Address owners = append(owners, common.HexToAddress(owner), common.HexToAddress(account)) tx, err := session.BalanceOfBatch(owners, tokenIDs) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"owners balance: %s\", tx)) } Query NFT Name Users can call this interface to query the name of the NFT. Input parameters: NFT token ID; Output parameters: NFT name; Function definition: tokenName (uint256 tokenID) view returns (string memory); Example: func TestTokenName(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(3) tx, err := session.TokenName(tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"NFT name: %s\", tx)) } Query NFT Symbol Users can call this interface to query the NFT symbol. Input parameters: NFT token ID; Output parameters: NFT symbol; Function definition: tokenSymbol (uint256 tokenID) view returns (string memory); Example: func TestTokenSymbol(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(2) tx, err := session.TokenSymbol(tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"NFT symbol: %s\", tx)) } Query NFT URI Users can call this interface to query the NFT URI. Input parameters: NFT token ID; Output parameters: NFT URI; Function definition: tokenURI (uint256 tokenID) view returns (string memory); Example: func TestTokenURI(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tokenId := new(big.Int).SetUint64(2) tx, err := session.TokenURI(tokenId) if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"NFT URI: %s\", tx)) } Query the Latest NFT Token ID Users can call this interface to query the latest NFT token ID. Input parameters: none; Output parameters: Latest NFT token ID; Function definition: getLatestTokenID() view returns (uint256); Example: func TestGetLatestTokenID(t *testing.T) { cli := server.NewETHClientByURL(t, url, key) session, err := e.NewERC1155Session(cli, common.HexToAddress(Address)) if err != nil { t.Fatal(err) } tx, err := session.GetLatestTokenID() if err != nil { t.Fatal(err) } fmt.Println(fmt.Sprintf(\"tokenId: %s\", tx)) Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"infoonthencchains/infoOntheNCChains.html":{"url":"infoonthencchains/infoOntheNCChains.html","title":"Info on the Non-Cryptocurrency Public Chains","keywords":"","body":"Info on the Non-Cryptocurrency Public Chains A Non-Cryptocurrency Public Chain is a transformed public chain framework based on an existing public chain. Gas Credit transfers are not permitted between standard wallets. There are no cryptocurrency incentives for mining or participating in consensus. On Spartan Network, there are three Non-Cryptocurrency Public Chains at launch. We expect to add more in the foreseeable future. Spartan-I Chain (Powered by NC Ethereum) About Spartan-I Chain (Powered by NC Ethereum) The Spartan-I Chain is a blockchain compatible with Ethereum that runs independently from the public Ethereum blockchain. Full Nodes, which can freely join and exit the Spartan Network, synchronize block information of the entire chain and submit transaction requests to the network. A Spartan-I full node runs an EVM (Ethereum Virtual Machine) that allows developers to use Solidity programming language to create smart contracts that are compatible with the Ethereum network. Also, all the different tools and wallets available for Ethereum (such as Truffle, HardHat, Metamask, etc…) can be directly used with Spartan-I Chain. Ethereum-based networks have two identifiers, a network ID and a chain ID. Although they often have the same value, they have different uses. Peer-to-peer communication between nodes uses the network ID, while the transaction signature process uses the chain ID. Spartan-I Chain Network Id = Chain Id = 9090 [!Tip|style:flat] For detailed installation documentation, please refer to GitHub. Ethereum and Geth Documentation Below is a list of useful online documentation about Ethereum and Geth. How to set up Geth and execute some basic tasks using the command line tools. https://geth.ethereum.org/docs/getting-started JSON-RPC API methods Interacting with Geth requires sending requests to specific JSON-RPC API methods. Geth supports all standard JSON-RPC API endpoints. You can send RPC requests on the port 8545. https://geth.ethereum.org/docs/rpc/server Developer Documentation This documentation is designed to help users build with Ethereum. It covers Ethereum as a concept, explains the Ethereum tech stack, and documents advanced topics for more complex applications and use cases. https://ethereum.org/en/developers/docs/ Smart Contract tutorials A list of curated Ethereum tutorials to learn about coding smart contracts and DApps. https://ethereum.org/en/developers/tutorials/ Solidity Lang https://docs.soliditylang.org/ Web3j Document https://docs.web3j.io/ Web3.js https://web3js.readthedocs.io/en/v1.7.5/ Spartan-II Chain (Powered by NC Cosmos) About Spartan-II Chain (Powered by NC Cosmos) The Spartan-II Chain is a Cosmos-based network which has two identifiers, a network ID and a chain ID. Although they often have the same value, they have different uses. Peer-to-peer communication between nodes uses the network ID, while the transaction signature process uses the chain ID. EVM module: Network ID = Chain ID = 9003 Native module: Network ID = Chain Id = starmint [!Tip|style:flat] For detailed installation instructions, please refer to GitHub. Resources To find out more about Spartan-II Chain (Powered by NC Cosmos), visit GitHub. API Introduction https://github.com/BSN-Spartan/NC-Cosmos/tree/main/docs/endpoints CLI Client Commands https://github.com/BSN-Spartan/NC-Cosmos/tree/main/docs/cli-client Solidity Lang https://docs.soliditylang.org/ Web3j Document https://docs.web3j.io/ Spartan-II Chain GoLang SDK https://github.com/BSN-Spartan/nc-cosmos-sdk-go Spartan-III Chain (Powered by NC PolygonEdge) About Spartan-III Chain (Powered by NC PolygonEdge) The Spartan-III Chain (Powered by NC PolygonEdge) network has two identifiers, a network ID and a chain ID. Although they often have the same value, they have different uses. Peer-to-peer communication between nodes uses the network ID, while the transaction signature process uses the chain ID. Spartan-III Chain Network Id = Chain Id = 5566 [!Tip|style:flat] For detailed installation instructions, please refer to GitHub. Resources JSON-RPC Commands NC PolygonEdge is compatible with ETH JSON RPC interface, please refer to the detailed interface list from below link. https://docs.polygon.technology/docs/edge/get-started/json-rpc-commands CLI Commands NC PolygonEdge provides a wealth of CLI commands for managing your nodes. For a detailed command list, please refer to the link below. https://docs.polygon.technology/docs/edge/get-started/cli-commands Prometheus Metrics PolygonEdge can report and serve the Prometheus metrics, which in their turn can be consumed using Prometheus collector(s). The following is a detailed description reference. https://docs.polygon.technology/docs/edge/configuration/prometheus-metrics Backup/Restore Node Instance This guide goes into detail on how to back up and restore a PolygonEdge node instance. It covers the base folders and what they contain, as well as which files are critical for performing a successful backup and restore. For detailed operation, please refer to the link below. https://docs.polygon.technology/docs/edge/working-with-node/backup-restore Polygon Edge API https://docs.polygon.technology/docs/edge/get-started/json-rpc-commands How to Use Smart Contracts https://docs.polygon.technology/docs/category/smart-contracts Solidity Lang https://docs.soliditylang.org/ Web3j Document https://docs.web3j.io/ Web3.js https://web3js.readthedocs.io/en/v1.7.5/ Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "},"faqs/FAQs.html":{"url":"faqs/FAQs.html","title":"FAQs","keywords":"","body":"FAQs Frequently Asked Questions Find answers and solutions for commonly seen errors and areas of confusion within our curated series of FAQ articles. Don't see your question answered here? Please contact us. What is a Wallet Address? In Spartan Non-Cryptocurrency Public Chains, a Wallet Address is a Gas Credit receiving address, which is a unique sequence of hexadecimal numbers. What is a Private Key? A private key is a secret number that is used in cryptography, similar to a password. In cryptocurrency, private keys are also used to sign transactions and prove ownership of a blockchain address. What is a Spartan Virtual Data Center? A Spartan Virtual Data Center is a set of locally installed software systems that contains one or more registered full nodes of different NC Public Chains. Each Virtual Data Center has one NTT wallet and is eligible to receive Node Establishment and Data Center Monthly Incentives. What is Gas Credit? In a similar fashion to cryptocurrencies, Gas Credits are used as a means of paying Gas fees on NC Public Chains. However, Gas Credits cannot be transferred between standard wallets. Only the Data Center Operator 's NTT wallet can be used to purchase Gas Credits with NTT. Copyright © 2022 Red Date (Hong Kong) Technology Limited all right reserved，powered by Gitbook "}}